<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Testing-S2S Live</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; background: #f8f9fa; }
    .container { max-width: 800px; margin: 0 auto; background: white; padding: 24px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    #status { margin: 12px 0; padding: 8px 12px; border-radius: 4px; font-weight: 500; }
    .status-connected { background: #d4edda; color: #155724; }
    .status-error { background: #f8d7da; color: #721c24; }
    .status-idle { background: #e2e3e5; color: #383d41; }
    .row { margin: 16px 0; }
    label { display: block; margin-bottom: 6px; font-weight: 500; }
    input[type=text] { width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; }
    input[type=range] { width: 200px; }
    button { padding: 10px 20px; margin-right: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-start { background: #28a745; color: white; }
    .btn-stop { background: #dc3545; color: white; }
    .btn-mute { background: #6c757d; color: white; }
    #logs { height: 300px; overflow: auto; background: #f8f9fa; border: 1px solid #dee2e6; padding: 12px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; }
    .audio-controls { margin: 16px 0; padding: 12px; background: #e9ecef; border-radius: 4px; }
    .volume-control { display: inline-block; margin-left: 15px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéß Testing-S2S Live</h1>
    <div id="status" class="status-idle">Idle - Click Start to begin</div>
    
    <div class="row">
      <label>WebSocket URL:</label>
      <input id="wsUrl" type="text" value="" placeholder="Auto-detected..." />
    </div>
    
    <div class="audio-controls">
      <div class="row">
        <button id="start" class="btn-start">üé§ Start Audio</button>
        <button id="stop" class="btn-stop" disabled>‚èπÔ∏è Stop</button>
        <button id="mute" class="btn-mute">üîä Mute</button>
        <div class="volume-control">
          <label>Volume:</label>
          <input id="volume" type="range" min="0" max="100" value="90" />
          <span id="volumeValue">90%</span>
        </div>
      </div>
      <small>üìù <strong>Instructions:</strong> Click Start, allow microphone, speak and pause to hear AI response in turn mode.</small>
    </div>
    
    <div class="row">
      <label>Connection Logs:</label>
      <div id="logs"></div>
    </div>
  </div>

<script>
const statusEl = document.getElementById('status');
const logsEl = document.getElementById('logs');
const wsUrlEl = document.getElementById('wsUrl');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const muteBtn = document.getElementById('mute');
const volumeSlider = document.getElementById('volume');
const volumeValue = document.getElementById('volumeValue');

let ws = null, media = null, ctx = null, proc = null, gain = null;
let workletNode = null;
let isMuted = false;

// Auto-detect WebSocket URL
function detectWebSocketUrl() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.host;
    return `${protocol}//${host}/ws/stream`;
}

// Set auto-detected URL on load
window.addEventListener('load', () => {
    const autoUrl = detectWebSocketUrl();
    wsUrlEl.value = autoUrl;
    log(`üîç Auto-detected WebSocket URL: ${autoUrl}`);
});

function setStatus(text, className) {
    statusEl.textContent = text;
    statusEl.className = className;
}

function log(m) { 
    const timestamp = new Date().toLocaleTimeString();
    logsEl.textContent += `[${timestamp}] ${m}\n`; 
    logsEl.scrollTop = logsEl.scrollHeight; 
}

function i16_to_f32(i16) {
    const f32 = new Float32Array(i16.length);
    for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768.0;
    return f32;
}

// Update volume
function updateVolume() {
    const vol = parseInt(volumeSlider.value) / 100;
    volumeValue.textContent = `${volumeSlider.value}%`;
    if (gain && ctx) {
        gain.gain.setValueAtTime(isMuted ? 0 : vol, ctx.currentTime);
    }
}

// Toggle mute
function toggleMute() {
    isMuted = !isMuted;
    muteBtn.textContent = isMuted ? 'üîá Unmute' : 'üîä Mute';
    updateVolume();
    log(isMuted ? 'üîá Audio muted' : 'üîä Audio unmuted');
}

async function ensureAudioWorklet() {
    if (!ctx) return;
    if (!ctx.audioWorklet) throw new Error('AudioWorklet not supported');
    await ctx.audioWorklet.addModule('/web/pcm-player-worklet.js');
    log('üß© AudioWorklet module loaded');
    workletNode = new AudioWorkletNode(ctx, 'pcm-player');
    gain = ctx.createGain();
    workletNode.connect(gain);
    gain.connect(ctx.destination);
    updateVolume();
    workletNode.port.onmessage = (e) => {
        const d = e.data;
        if (d.type === 'level') {
            log(`üì¶ Buffer level: ${d.available} samples`);
        } else if (d.type === 'underrun') {
            log(`‚ö†Ô∏è Underrun: need ${d.need}, available ${d.available}`);
        }
    };
}

async function start() {
    const url = wsUrlEl.value.trim();
    if (!url) { alert('‚ùå Please enter WebSocket URL'); return; }
    try {
        log('üîå Connecting to WebSocket...');
        setStatus('Connecting...', 'status-idle');

        ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        if (ctx.state === 'suspended') { await ctx.resume(); }
        log(`üéµ AudioContext: ${ctx.state}, ${ctx.sampleRate} Hz`);
        await ensureAudioWorklet();

        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';
        ws.onopen = () => { log('‚úÖ WebSocket connected'); setStatus('Connected - Ready for audio', 'status-connected'); };
        ws.onclose = (ev) => { log(`‚ùå WS closed: ${ev.code} ${ev.reason||''}`); setStatus('Connection closed', 'status-error'); };
        ws.onerror = (e) => { log('‚ùå WS error'); console.error(e); setStatus('Connection error', 'status-error'); };
        ws.onmessage = (ev) => {
            if (!(ev.data instanceof ArrayBuffer)) return;
            const i16 = new Int16Array(ev.data);
            const f32 = i16_to_f32(i16);
            // Send to worklet ring buffer
            if (workletNode) {
                workletNode.port.postMessage({ type: 'push', samples: f32 }, [f32.buffer]);
                log(`üîä Queued ${i16.length} samples to worklet`);
            }
        };

        // Mic capture (unchanged)
        log('üé§ Requesting microphone access...');
        media = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, sampleRate: 24000, echoCancellation: true, noiseSuppression: true, autoGainControl: true } });
        log('‚úÖ Microphone access granted');
        const source = ctx.createMediaStreamSource(media);
        proc = ctx.createScriptProcessor(2048, 1, 1);
        proc.onaudioprocess = (e) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            if (ctx.state === 'suspended') ctx.resume();
            const ch = e.inputBuffer.getChannelData(0);
            const size = 1920; // 80ms at 24kHz
            for (let i = 0; i < ch.length; i += size) {
                const sl = ch.subarray(i, Math.min(i + size, ch.length));
                const buf = new ArrayBuffer(sl.length * 2);
                const view = new DataView(buf);
                for (let k = 0, off = 0; k < sl.length; k++, off += 2) {
                    let s = Math.max(-1, Math.min(1, sl[k]));
                    view.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
                ws.send(buf);
            }
        };
        source.connect(proc); proc.connect(ctx.destination);

        startBtn.disabled = true; stopBtn.disabled = false;
        log('üéµ Pipeline ready - speak now!');
    } catch (err) {
        log(`‚ùå Setup error: ${err.message}`);
        console.error(err);
        stop();
    }
}

function stop() {
    if (proc) { proc.disconnect(); proc = null; log('üîá Processor disconnected'); }
    if (workletNode) { workletNode.disconnect(); workletNode = null; log('üß© Worklet disconnected'); }
    if (gain) { gain.disconnect(); gain = null; log('üéöÔ∏è Gain disconnected'); }
    if (ctx && ctx.state !== 'closed') { ctx.close(); ctx = null; log('üîá AudioContext closed'); }
    if (media) { media.getTracks().forEach(t => t.stop()); media = null; log('üõë Mic stopped'); }
    if (ws) { ws.close(); ws = null; log('üîå WS disconnected'); }
    startBtn.disabled = false; stopBtn.disabled = true; setStatus('Stopped', 'status-idle');
}

startBtn.onclick = start; stopBtn.onclick = stop; muteBtn.onclick = toggleMute; volumeSlider.oninput = updateVolume;

document.addEventListener('visibilitychange', () => { if (!document.hidden && ctx && ctx.state === 'suspended') { ctx.resume().then(() => log('üîÑ AudioContext resumed after tab focus')); } });
</script>
</body>
</html>